/*****************************************************************************************************
 * @name:       LivIconsEvo.min.js - the main (minified) JS file of LivIcons (Live Icons) Evolution
 * @version:    2.4.XXX (XXX is a total number of icons)
 * @URL:        https://livicons.com
 * @copyright:  (c) 2013-2018 DeeThemes (http://codecanyon.net/user/DeeThemes)
 * @licenses:   http://codecanyon.net/licenses/regular
                http://codecanyon.net/licenses/extended
******************************************************************************************************/

(function(k, C) {
    function M(b, a) {
        b.css("visibility", "hidden");
        var e = n(b.find("svg")[0]);
        e.attr({ preserveAspectRatio: "xMinYMin meet" });
        var c = e.attr("viewBox").w / 2 + " " + e.attr("viewBox").h / 2;
        e.selectAll("desc").forEach(function(a) { "Created with Snap" == a.innerSVG() && k(a.node).text("LivIcons Evolution") });
        var f = k(e.node),
            w = e.select("g.lievo-main"),
            g = e.g().addClass("lievo-setrotation");
        e.prepend(g);
        g = g.g().addClass("lievo-setsharp");
        g = g.g().addClass("lievo-setflip");
        g.append(w);
        a.morph ? "end" === a.morphState ?
            (f.find("g.lievo-main g.lievo-morphstartstate").remove(), a.curMorphState = "end") : (f.find("g.lievo-main g.lievo-morphendstate").remove(), a.curMorphState = "start") : a.curMorphState = "not morph";
        switch (a.style) {
            case "solid":
                f.find("g.lievo-main g.lievo-solidicon").siblings(":not(g.lievo-common)").remove();
                break;
            case "lines":
            case "lines-alt":
            case "linesAlt":
                f.find("g.lievo-main g.lievo-lineicon").siblings(":not(g.lievo-common)").remove();
                break;
            default:
                f.find("g.lievo-main g.lievo-filledicon").siblings(":not(g.lievo-common)").remove()
        }
        f =
            w.rect(-19, -19, 4, 4).addClass("lievo-checkshift lievo-donotdraw lievo-nohoverstroke lievo-nohovercolor").attr({ fill: "none", stroke: "#ffffff", "stroke-width": 2, "stroke-linecap": "butt", "stroke-linejoin": "round", opacity: 0 });
        e.attr("data-shift") && ("x" === e.attr("data-shift") ? f.attr("x", -20) : "y" === e.attr("data-shift") ? f.attr("y", -20) : "xy" === e.attr("data-shift") && f.attr({ x: -20, y: -20 }));
        "solid" === a.style && e.attr("data-solidshift") && ("x" === e.attr("data-solidshift") ? f.attr("x", -19.5) : "y" === e.attr("data-solidshift") ?
            f.attr("y", -19.5) : "xy" === e.attr("data-solidshift") && f.attr({ x: -19.5, y: -19.5 }));
        if (a.morph && a.morphImage) {
            if (e.select(".lievo-morphimage")) {
                var d = e.ptrn(0, 0, "100%", "100%", 0, 0, 0, 0);
                d.node.removeAttribute("viewBox");
                var l = d.attr("patternUnits", "userSpaceOnUse").addClass("lievo-morphpattern").toDefs().g()
            } else a.morphImage = !1;
            f = e.select(".lievo-morphimage").attr("fill");
            l.rect(0, 0, 60, 60).attr({ fill: f, stroke: "#ffffff", "stroke-width": 0 }).addClass("lievo-donotdraw")
        }
        var q = e.selectAll("circle, ellipse, image, line, path, polygon, polyline, rect, text, use");
        q.forEach(function(a) {
            k(a.node).attr("stroke") || a.attr({ stroke: "none", "stroke-width": 0 });
            k(a.node).attr("fill") || a.attr("fill", "none")
        });
        "round" === a.strokeStyle ? q.forEach(function(a) { "none" === a.attr("stroke") || a.hasClass("lievo-savelinecap") || (a.node.setAttribute("stroke-linecap", "round"), a.node.setAttribute("stroke-linejoin", "round")) }) : "square" === a.strokeStyle && q.forEach(function(a) {
            "none" === a.attr("stroke") || a.hasClass("lievo-savelinecap") || (a.node.setAttribute("stroke-linecap", "square"), a.node.setAttribute("stroke-linejoin",
                "miter"), a.attr("stroke-miterlimit") || a.attr("stroke-miterlimit", "10"))
        });
        q.forEach(function(a) {
            a.data("initStrokeWidth", a.attr("stroke-width"));
            a.data("initStrokeLinecap", a.attr("stroke-linecap"));
            a.data("initStrokeLinejoin", a.attr("stroke-linejoin"))
        });
        switch (a.style) {
            case "filled":
                q.forEach(function(b) {
                    "none" === b.attr("stroke") || b.hasClass("lievo-savestroke") || b.attr("stroke", a.strokeColor);
                    "none" === b.attr("fill") || b.hasClass("lievo-savefill") || b.attr("fill", a.fillColor);
                    b.hasClass("lievo-likestroke") &&
                        b.attr("fill", a.strokeColor)
                });
                break;
            case "lines":
                q.forEach(function(b) {
                    "none" === b.attr("stroke") || b.hasClass("lievo-savestroke") || b.attr("stroke", a.strokeColor);
                    b.hasClass("lievo-savefill") || b.attr("fill", "none");
                    b.hasClass("lievo-likestroke") && b.attr("fill", a.strokeColor)
                });
                break;
            case "lines-alt":
            case "linesAlt":
                q.forEach(function(b) {
                    b.hasClass("lievo-altstroke") ? ("none" !== b.attr("stroke") && b.attr("stroke", a.strokeColorAlt), b.hasClass("lievo-likestroke") ? b.attr("fill", a.strokeColorAlt) : b.hasClass("lievo-savefill") ||
                        b.attr("fill", "none")) : ("none" === b.attr("stroke") || b.hasClass("lievo-savestroke") || b.attr("stroke", a.strokeColor), b.hasClass("lievo-likestroke") ? b.attr("fill", a.strokeColor) : b.hasClass("lievo-savefill") || b.attr("fill", "none"))
                });
                break;
            case "solid":
                q.forEach(function(b) {
                    b.hasClass("lievo-solidbg") ? ("none" === b.attr("stroke") || b.hasClass("lievo-savestroke") || b.attr("stroke", a.solidColorBg), "none" === b.attr("fill") || b.hasClass("lievo-savefill") || b.attr("fill", a.solidColorBg)) : ("none" === b.attr("stroke") ||
                        b.hasClass("lievo-savestroke") || b.attr("stroke", a.solidColor), "none" === b.attr("fill") || b.hasClass("lievo-savefill") || b.attr("fill", a.solidColor))
                })
        }
        b.css("width", a.size);
        v && b.hasClass("livicon-evo-back-in-combined") && (b.parent(".livicon-evo-combined").css("width", a.size), b.css("width", "100%"));
        a.morph && a.morphImage && (l.image(a.morphImage, 0, 0, "100%", "100%"), d.select("image").attr("preserveAspectRatio", "xMidYMid slice"), e.select(".lievo-morphimage").attr("fill", d));
        var r, N = function() {
            a.scaleStrokeFactor =
                b.width() / 60;
            0 >= a.scaleStrokeFactor && (a.scaleStrokeFactor = 1);
            "original" !== a.strokeWidth ? (q.forEach(function(b) {
                if ("none" !== b.attr("stroke")) {
                    var c = ("" + a.strokeWidth).replace(/[0-9.]/g, ""),
                        d = b.data("initStrokeWidth").replace(/[^0-9.]/g, "") / 2,
                        d = +("" + a.strokeWidth).replace(/[^0-9.]/g, "") / a.scaleStrokeFactor * d;
                    b.node.setAttribute("stroke-width", d + c);
                    b.data("curStrokeWidth", d + c)
                }
            }), r = ("" + a.strokeWidth).replace(/[^0-9.]/g, "") / a.scaleStrokeFactor / 2) : a.tryToSharpen && .5 > a.scaleStrokeFactor ? (q.forEach(function(b) {
                if ("none" !==
                    b.attr("stroke")) {
                    var c = b.data("initStrokeWidth").replace(/[0-9.]/g, ""),
                        d = b.data("initStrokeWidth").replace(/[^0-9.]/g, "") / 2,
                        d = 1 / a.scaleStrokeFactor * d;
                    b.node.setAttribute("stroke-width", d + c);
                    b.data("curStrokeWidth", d + c)
                }
            }), r = 1 / a.scaleStrokeFactor / 2) : (q.forEach(function(a) { "none" !== a.attr("stroke") && a.data("curStrokeWidth", a.data("initStrokeWidth")) }), r = e.select(".lievo-checkshift").attr("stroke-width").replace(/[^0-9.]/g, "") / 2);
            (0 === a.strokeWidthFactorOnHover || a.strokeWidthFactorOnHover) && q.forEach(function(b) {
                if ("none" !==
                    b.attr("stroke") && !b.hasClass("lievo-nohoverstroke")) {
                    var c = b.data("curStrokeWidth");
                    if (c) {
                        var d = ("" + c).replace(/[0-9.]/g, ""),
                            c = +("" + c.replace(/[^0-9.]/g, "")) * a.strokeWidthFactorOnHover;
                        b.data("hoverStrokeWidth", c + d)
                    }
                }
            })
        };
        N();
        if (a.keepStrokeWidthOnResize) k(window).on("resize", function() { N() });
        if (a.colorsOnHover) var m = a.colorsOnHover;
        a.morph && a.colorsWhenMorph && (a.colorsOnHover = !1, m = a.colorsWhenMorph);
        q.forEach(function(b) {
            var c = k(b.node).attr("fill");
            b.data("curFill", c);
            b.data("curStroke", b.attr("stroke"));
            b.data("curOpacity", b.attr("opacity"));
            if (m) {
                if ("none" === c) b.data("actionFill", "none");
                else if (c.toLowerCase().match(/url\(/)) b.data("actionFill", c);
                else {
                    if ("lighter" === m) var d = "solid" === a.style && b.hasClass("lievo-solidbg") ? a.solidColorBgAction : G(c, -a.saturation, a.brightness);
                    else if ("darker" === m) d = "solid" === a.style && b.hasClass("lievo-solidbg") ? a.solidColorBgAction : G(c, a.saturation, -a.brightness);
                    else if ("hue" === m.replace(/[^hue]/g, "")) d = "solid" === a.style && b.hasClass("lievo-solidbg") ? a.solidColorBgAction :
                        O(c, m.replace(/[^0-9.]/g, "") ? m.replace(/[^0-9.]/g, "") : 0);
                    else if ("custom" === m) switch (a.style) {
                        case "solid":
                            d = b.hasClass("lievo-solidbg") ? a.solidColorBgAction : a.solidColorAction;
                            break;
                        case "lines":
                            d = a.strokeColorAction;
                            break;
                        case "lines-alt":
                        case "linesAlt":
                            d = b.hasClass("lievo-altstroke") ? a.strokeColorAltAction : a.strokeColorAction;
                            break;
                        default:
                            d = b.hasClass("lievo-likestroke") ? a.strokeColorAction : a.fillColorAction
                    }
                    b.data("actionFill", d)
                }
                if ("none" === b.attr("stroke")) b.data("actionStroke", "none");
                else {
                    if ("lighter" ===
                        m) d = "solid" === a.style && b.hasClass("lievo-solidbg") ? a.solidColorBgAction : G(b.attr("stroke"), -a.saturation, a.brightness);
                    else if ("darker" === m) d = "solid" === a.style && b.hasClass("lievo-solidbg") ? a.solidColorBgAction : G(b.attr("stroke"), a.saturation, -a.brightness);
                    else if ("hue" === m.replace(/[^hue]/g, "")) d = "solid" === a.style && b.hasClass("lievo-solidbg") ? a.solidColorBgAction : O(b.attr("stroke"), m.replace(/[^0-9.]/g, "") ? m.replace(/[^0-9.]/g, "") : 0);
                    else if ("custom" === m) switch (a.style) {
                        case "solid":
                            d = b.hasClass("lievo-solidbg") ?
                                a.solidColorBgAction : a.solidColorAction;
                            break;
                        case "lines":
                            d = a.strokeColorAction;
                            break;
                        case "lines-alt":
                        case "linesAlt":
                            d = b.hasClass("lievo-altstroke") ? a.strokeColorAltAction : a.strokeColorAction;
                            break;
                        default:
                            d = a.strokeColorAction
                    }
                    b.data("actionStroke", d)
                }
            }
        });
        a.rotate && (h.set(e.select("g.lievo-setrotation").node, { rotation: a.rotate, svgOrigin: c }), a.morph && a.morphImage && !a.allowMorphImageTransform && (l = d.select("g"), !a.flipVertical && a.flipHorizontal ? l.transform("r" + a.rotate + ",30,30") : a.flipVertical &&
            !a.flipHorizontal ? l.transform("r" + a.rotate + ",30,30") : l.transform("r" + -a.rotate + ",30,30")));
        a.flipVertical && !a.flipHorizontal ? (e.select("g.lievo-setflip").transform("s1,-1,30,30"), a.morph && a.morphImage && !a.allowMorphImageTransform && d.select("image").transform("s1,-1,30,30")) : a.flipHorizontal && !a.flipVertical ? (e.select("g.lievo-setflip").transform("s-1,1,30,30"), a.morph && a.morphImage && !a.allowMorphImageTransform && d.select("image").transform("s-1,1,30,30")) : a.flipVertical && a.flipHorizontal && (e.select("g.lievo-setflip").transform("s-1,-1,30,30"),
            a.morph && a.morphImage && !a.allowMorphImageTransform && d.select("image").transform("s-1,-1,30,30"));
        a.animated ? (e.attr("data-animoptions") ? (d = JSON.parse(e.attr("data-animoptions").replace(/\'/g, '"')), a.def_duration = d.duration ? u(d.duration) : 1, a.def_repeat = d.repeat ? "loop" === d.repeat ? -1 : u(d.repeat) : 0, a.def_repeatDelay = d.repeatDelay ? u(d.repeatDelay) : .5) : (a.def_duration = 1, a.def_repeat = 0, a.def_repeatDelay = .5), a.use_duration = "default" === a.duration ? a.def_duration : u(a.duration), isNaN(a.use_duration) && (a.use_duration =
            1), a.use_repeat = "default" === a.repeat ? a.def_repeat : "loop" === a.repeat ? -1 : u(a.repeat), isNaN(a.use_repeat) && (a.use_repeat = 0), -1 !== a.use_repeat && 0 > a.use_repeat && (a.use_repeat = 0), a.use_repeatDelay = "default" === a.repeatDelay ? a.def_repeatDelay : u(a.repeatDelay), isNaN(a.use_repeatDelay) && (a.use_repeatDelay = a.def_repeatDelay), 0 >= a.delay && (a.delay = .001), 0 >= a.use_repeatDelay && (a.use_repeatDelay = .001), 0 >= a.drawDelay && (a.drawDelay = .001), 0 >= a.eraseDelay && (a.eraseDelay = .001), a.morph && (a.def_repeat = 0, a.use_repeat = 0,
            a.def_repeatDelay = 0, a.use_repeatDelay = 0)) : (a.def_duration = 0, a.def_repeat = 0, a.def_repeatDelay = 0);
        var t = b.data("drawTL");
        t ? t.pause().kill().clear() : t = new y({ paused: !0 });
        var p = b.data("mainTL");
        p ? p.pause().kill().clear() : p = new y({ paused: !0 });
        if (a.animated) {
            var d = e.selectAll("circle, ellipse, g, image, line, path, polygon, polyline, rect, text, use"),
                B = new y;
            if (a.morph && a.colorsWhenMorph) {
                var z = new y;
                d.forEach(function(b) {
                    if ("end" !== a.morphState) {
                        if (!b.hasClass("lievo-nohovercolor") && "g" !== b.type.toLowerCase()) {
                            var c =
                                b.data("actionStroke"),
                                d = b.data("actionFill");
                            c && "none" !== c && (c = h.to(b.node, a.use_duration, { stroke: c }), z.add(c, 0));
                            d && "none" !== d && !d.match(/url\(/) && (b = h.to(b.node, a.use_duration, { fill: d }), z.add(b, 0))
                        }
                    } else b.hasClass("lievo-nohovercolor") || "g" === b.type.toLowerCase() || (c = b.data("actionStroke"), d = b.data("actionFill"), c && "none" !== c && h.set(b.node, { stroke: c }), d && "none" !== d && !d.match(/url\(/) && h.set(b.node, { fill: d }), c = b.data("curStroke"), d = b.data("curFill"), c && "none" !== c && (c = h.to(b.node, a.use_duration, { stroke: c }), z.add(c, 0)), d && "none" !== d && !d.match(/url\(/) && (b = h.to(b.node, a.use_duration, { fill: d }), z.add(b, 0)))
                })
            }
            d.forEach(function(a) {
                if (a.attr("data-animdata")) {
                    var b = JSON.parse(a.attr("data-animdata").replace(/\'/g, '"')),
                        c = new y;
                    b.steps.forEach(function(b, d) {
                        for (var g in b.vars) b.vars.hasOwnProperty(g) && (b.vars[g] = u(b.vars[g]), "none" !== b.vars[g] && (b.vars[g] = A(b.vars[g])));
                        0 === u(b.duration) && (b.duration = .001);
                        b.vars.ease = "none" !== b.vars.ease && b.vars.ease ? J(b.vars.ease) : P.easeNone;
                        b.vars.path && (b.vars.morphSVG =
                            b.vars.path);
                        if (b.vars.bezier && b.vars.bezier.values && "string" === typeof b.vars.bezier.values)
                            for (g = n.path.toCubic(b.vars.bezier.values).toString(), g = g.replace(/[M|m]/g, "").replace(/[C|c]/g, ","), g = g.split(","), b.vars.bezier.values = [], d = 0; d < g.length; d += 2) {
                                var e = {};
                                e.x = g[d];
                                e.y = g[d + 1];
                                b.vars.bezier.values.push(e)
                            }
                        K || L ? b.vars.drawSVG ? "0%" === b.vars.drawSVG || 0 === b.vars.drawSVG ? (g = h.to(a.node, +b.duration, b.vars), g.eventCallback("onStart", function() {
                            "square" === a.data("initStrokeLinecap").toLowerCase() && h.set(a.node, { attr: { "stroke-linecap": "round" } });
                            "miter" === a.data("initStrokeLinejoin").toLowerCase() && h.set(a.node, { attr: { "stroke-linejoin": "round" } })
                        })) : "100%" === b.vars.drawSVG ? (g = h.to(a.node, +b.duration, b.vars), g.eventCallback("onComplete", function() { "square" === a.data("initStrokeLinecap").toLowerCase() && h.set(a.node, { attr: { "stroke-linecap": "square" } }); "miter" === a.data("initStrokeLinejoin").toLowerCase() && h.set(a.node, { attr: { "stroke-linejoin": "miter" } }) })) : g = h.to(a.node, +b.duration, b.vars) : g = h.to(a.node, +b.duration,
                            b.vars) : g = h.to(a.node, +b.duration, b.vars);
                        c.add(g, b.position || "+=0");
                        B.add(c, 0)
                    });
                    a.node.removeAttribute("data-animdata")
                }
            });
            p.add(B, 0);
            B.duration(a.use_duration);
            a.morph && a.colorsWhenMorph && (p.add(z, 0), z.duration(a.use_duration));
            p.delay(a.delay).repeat(a.use_repeat).repeatDelay(a.use_repeatDelay)
        } else q = e.selectAll("circle, ellipse, g, image, line, path, polygon, polyline, rect, text, use"), q.forEach(function(a) { a.node.removeAttribute("data-animdata") });
        b.data("drawTL", t);
        b.data("mainTL", p);
        a.event_elem =
            "self" !== a.eventOn && a.eventOn ? "parent" === a.eventOn ? b.parent() : "grandparent" === a.eventOn ? b.parent().parent() : k(a.eventOn) : b;
        v && b.hasClass("livicon-evo-back-in-combined") && ((d = b.parent(".livicon-evo-combined"), "self" !== a.eventOn && a.eventOn) ? "parent" === a.eventOn ? a.event_elem = d.parent() : "grandparent" === a.eventOn && (a.event_elem = d.parent().parent()) : a.event_elem = d);
        v && b.parent().hasClass("livicon-evo-front-in-combined") && ((d = b.parent(".livicon-evo-front-in-combined"), "self" !== a.eventOn && a.eventOn) ? "parent" ===
            a.eventOn ? a.event_elem = d.parent() : "grandparent" === a.eventOn && (a.event_elem = d.parent().parent()) : a.event_elem = b);
        if (a.animated)
            if (!a.morph)
                if ("click" === a.eventType) a.event_elem.on("click.LiviconEvo", function() {
                    -1 === a.use_repeat ? a.ending ? p.isActive() && p.tweenTo(p.duration(), {
                        onComplete: function() {
                            p.pause().totalProgress(0);
                            "function" == typeof a.afterAnim && a.afterAnim();
                            a.ending = !1
                        }
                    }) : a.drawn && (a.ending = !0, b.playLiviconEvo()) : a.drawn && (b.playLiviconEvo(), a.ending = !1)
                });
                else {
                    if ("hover" === a.eventType)
                        if (d =
                            function() { a.ending || a.drawn && b.playLiviconEvo() }, l = function() {
                                p.isActive() && (a.ending = !0, p.tweenTo(p.duration(), {
                                    onComplete: function() {
                                        p.pause().totalProgress(0); - 1 === a.use_repeat && "function" == typeof a.afterAnim && a.afterAnim();
                                        a.ending = !1
                                    }
                                }))
                            }, -1 === a.use_repeat) a.event_elem.on("mouseenter.LiviconEvo", d).on("mouseleave.LiviconEvo", l);
                        else a.event_elem.on("mouseenter.LiviconEvo", function() { a.drawn && b.playLiviconEvo() })
                }
        else if (a.morph)
            if ("click" === a.eventType) a.event_elem.on("click.LiviconEvo", function() {
                a.drawn &&
                    b.playLiviconEvo()
            });
            else "hover" === a.eventType && (l = function() { a.drawn && p.reverse() }, a.event_elem.on("mouseenter.LiviconEvo", function() { a.drawn && b.playLiviconEvo() }).on("mouseleave.LiviconEvo", l));
        if (a.colorsOnHover) a.event_elem.on("mouseenter.LiviconEvo", function() {
            !t.isActive() && a.drawn && q.forEach(function(b) {
                if (!b.hasClass("lievo-nohovercolor")) {
                    var c = b.data("actionStroke"),
                        d = b.data("actionFill");
                    c && "none" !== c && h.to(b.node, a.colorsHoverTime, { stroke: c });
                    d && "none" !== d && !d.match(/url\(/) && h.to(b.node,
                        a.colorsHoverTime, { fill: d })
                }
            })
        }).on("mouseleave.LiviconEvo", function() {
            !t.isActive() && a.drawn && q.forEach(function(b) {
                if (!b.hasClass("lievo-nohovercolor")) {
                    var c = b.data("curStroke"),
                        d = b.data("curFill");
                    c && "none" !== c && h.to(b.node, a.colorsHoverTime, { stroke: c });
                    d && "none" !== d && !d.match(/url\(/) && h.to(b.node, a.colorsHoverTime, { fill: d })
                }
            })
        });
        if (0 === a.strokeWidthFactorOnHover || a.strokeWidthFactorOnHover) a.event_elem.on("mouseenter.LiviconEvo", function() {
            !t.isActive() && a.drawn && q.forEach(function(b) {
                if (!b.hasClass("lievo-nohoverstroke")) {
                    var c =
                        b.data("hoverStrokeWidth");
                    c && h.to(b.node, a.strokeWidthOnHoverTime, { attr: { "stroke-width": c } })
                }
            })
        }).on("mouseleave.LiviconEvo", function() {
            !t.isActive() && a.drawn && q.forEach(function(b) {
                if (!b.hasClass("lievo-nohoverstroke")) {
                    var c = b.data("curStrokeWidth");
                    c && h.to(b.node, a.strokeWidthOnHoverTime, { attr: { "stroke-width": c } })
                }
            })
        });
        if (a.touchEvents && (a.animated || a.colorsOnHover || 0 === a.strokeWidthFactorOnHover || a.strokeWidthFactorOnHover)) a.event_elem.on("touchstart.LiviconEvo", function(b) {
            b.preventDefault();
            a.event_elem.trigger("mouseenter.LiviconEvo")
        }).on("touchend.LiviconEvo", function() {
            a.event_elem.trigger("mouseleave.LiviconEvo");
            try { a.event_elem[0].click() } catch (R) {
                if ("function" == typeof document.createEvent) {
                    var b = document.createEvent("MouseEvents");
                    b.initMouseEvent("click", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null);
                    a.event_elem.get(0).dispatchEvent(b)
                } else "function" == typeof window.MouseEvent && (b = new MouseEvent("click", { bubbles: !0, cancelable: !0 }), a.event_elem.get(0).dispatchEvent(b))
            }
        });
        if (d = b.find("svg")[0].getScreenCTM()) l = -d.e % 1, f = -d.f % 1, 0 == l ? l = 0 : -.5 >= l && (l += 1), 0 == f ? f = 0 : -.5 >= f && (f += 1), b.find("svg").css({ left: l + "px", top: f + "px" }), a.tryToSharpen && (l = e.select(".lievo-checkshift"), f = e.select(".lievo-morphpattern"), w = n.matrix(), l && (l = l.getBBox(), 0 !== (l.x + r) * d.a % 1 && (h.set(e.select("g.lievo-setsharp").node, { x: "+=" + ((l.x - r) * d.a % 1 / d.a || 0), svgOrigin: c }), w.e = (l.x - r) * d.a % 1 / d.a || 0), 0 !== (l.y + r) * d.d % 1 && (h.set(e.select("g.lievo-setsharp").node, { y: "+=" + ((l.y - r) * d.d % 1 / d.d || 0), svgOrigin: c }), w.f = (l.y - r) * d.d % 1 / d.d || 0), f && f.attr("patternTransform",
            w.toString())));
        if (a.drawOnViewport && !a.drawOnce) {
            var x, c = b.find("svg").get(0).getBoundingClientRect().height;
            switch (a.viewportShift) {
                case "none":
                case !1:
                    x = 1;
                    break;
                case "one-half":
                case "oneHalf":
                    x = c / 2;
                    break;
                case "one-third":
                case "oneThird":
                    x = c / 3;
                    break;
                case "full":
                    x = c;
                    break;
                default:
                    x = c / 2
            }
            var E = function() {
                if (!a.drawOnce) {
                    var c = k(window).height();
                    x > c && (x = c - 10);
                    Q.inViewport(b, -x) && (b.pauseLiviconEvo(), b.drawLiviconEvo(), a.drawOnce = !0)
                }
            };
            E();
            k(window).on("resize scroll", function() { E() })
        } else b.css("visibility",
            "visible"), a.drawOnce = !0, a.drawn = !0, a.autoPlay && b.playLiviconEvo()
    }

    function H() { return H.counter++ }

    function I(b) {
        if (null == b || "object" != typeof b) return b;
        var a = new b.constructor,
            e;
        for (e in b) a[e] = I(b[e]);
        return a
    }

    function A(b) {
        if ("string" == typeof b || b instanceof String) switch (b.toLowerCase()) {
            case "true":
            case "yes":
                return !0;
            case "false":
            case "no":
            case "none":
                return !1;
            default:
                return b
        } else return b
    }

    function u(b) { return "string" == typeof b || b instanceof String ? +b || "0" == b ? +b : b : b }

    function J(b) {
        var a = b.split(".");
        if (2 === a.length && "SteppedEase" !== a[0]) return v ? window.DeeThemes_GS[a[0]][a[1]] : window[a[0]][a[1]];
        b = b.match(/true|false|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig).map(JSON.parse);
        return "SteppedEase" !== a[0] ? v ? window.DeeThemes_GS[a[0]][a[1]].config.apply(null, b) : window[a[0]][a[1]].config.apply(null, b) : v ? window.DeeThemes_GS[a[0]].config.apply(null, b) : window[a[0]].config.apply(null, b)
    }

    function G(b, a, e) {
        b = n.color(b);
        b = n.rgb2hsb(b.r, b.g, b.b);
        b.s += a;
        0 > b.s && (b.s = 0);
        1 < b.s && (b.s = 1);
        b.b += e;
        0 > b.b && (b.b = 0);
        1 < b.b &&
            (b.b = 1);
        return n.hsb(b.h, b.s, b.b)
    }

    function O(b, a) {
        var e = n.color(b),
            e = n.rgb2hsb(e.r, e.g, e.b);
        a = Math.abs(a) / 360 % 1;
        e.h = (e.h + a) % 1;
        return n.hsb(e.h, e.s, e.b)
    }
    var v = !1,
        h = window.TweenMax,
        y = window.TimelineMax,
        P = window.Power0,
        n = window.Snap,
        Q = window.verge;
    window.DeeThemes_GS && window.DeeThemes_Snap && window.DeeThemes_Verge && (v = !0);
    v && (h = window.DeeThemes_GS.TweenMax, y = window.DeeThemes_GS.TimelineMax, P = window.DeeThemes_GS.Power0, n = window.DeeThemes_Snap, Q = window.DeeThemes_Verge);
    var F = LivIconsEvoDefaults();
    F.pathToFolder.match(/(\/)$/) ||
        "" === F.pathToFolder.trim() || (F.pathToFolder += "/");
    var K = "ActiveXObject" in window ? !0 : !1,
        L = navigator.userAgent.match(/Edge\/\d+/) ? !0 : !1;
    k.fn.extend({
        addLiviconEvo: function(b, a) {
            if (2 > arguments.length) var e = b === Object(b) ? b : {};
            else b === Object(b) ? e = b : (e = {}, e[b] = a);
            return this.each(function() {
                var a = k(this),
                    b = a.data("options"),
                    w = a.data("saved_options"),
                    g = {};
                a.addClass("livicon-evo-holder");
                w && w.event_elem && (w.event_elem.off(".LiviconEvo"), w.event_elem = C);
                b && (b = b.split(";"), b.forEach(function(a) {
                    a = a.trim().split(/:(.+)/);
                    a[0] && a[1] && (g[a[0].trim()] = a[1].trim())
                }));
                g = k.extend(I(F), g, e);
                if (g.name) {
                    g.name.match(/(\.svg)$/) || (g.name += ".svg");
                    for (var d in g) g.hasOwnProperty(d) && (g[d] = u(g[d]), g[d] = A(g[d]));
                    g.name.match(/morph+(-)/) ? g.morph = !0 : g.morph = !1;
                    g.drawOnce = !1;
                    g.drawn = !1;
                    g.ending = !1;
                    a.removeData("saved_options");
                    a.data("saved_options", g);
                    "function" == typeof g.beforeAdd && g.beforeAdd();
                    k.ajax({
                        url: g.pathToFolder + g.name,
                        type: "GET",
                        dataType: "text",
                        global: !0,
                        success: function(b) {
                            a.removeClass("livicon-evo-error");
                            var c =
                                b.match(/(id=[\"'](.*?)[\"'])/gi);
                            c && c.forEach(function(a) {
                                a = a.replace(/id=[\"']/i, "").replace(/[\"']/, "");
                                b = b.replace(new RegExp(a, "g"), a + "_" + H())
                            });
                            b = n.parse(b);
                            c = a.empty().append("<div>").children().addClass("lievo-svg-wrapper");
                            try { c[0].appendChild(b.node) } catch (r) { c.html(b.node) }
                            M(a, g);
                            "function" == typeof g.afterAdd && g.afterAdd()
                        },
                        error: function(b, c) {
                            a.addClass("livicon-evo-error");
                            0 === b.status && "error" === c ? a.html('<span><acronym title="Please use LivIconsEvo script on a working local or internet connected webserver, it does NOT work directly opened from a HDD.">Network Error</acronym></span>') :
                                404 === b.status && "error" === c ? a.html('<span><acronym title="Please check the &quot;name&quot; option and/or default &quot;pathToFolder&quot; one where all SVG LivIconEvo files are placed.">Not Found</acronym></span>') : a.html('<span><acronym title="There is an unknown error. Please check for messages in Console (F12 key).">Unknown Error</acronym></span>')
                        }
                    })
                } else a.addClass("livicon-evo-error").html('<span><acronym title="Please check the &quot;name&quot; option of your SVG LivIconEvo file.">Name Error</acronym></span>')
            })
        },
        updateLiviconEvo: function(b, a) {
            if (2 > arguments.length) var e = b === Object(b) ? b : {};
            else b === Object(b) ? e = b : (e = {}, e[b] = a);
            return this.each(function() {
                var a = k(this),
                    b = a.data("saved_options");
                if (b) {
                    b.event_elem && b.event_elem.off(".LiviconEvo");
                    b.event_elem = C;
                    b = I(b);
                    b = k.extend(b, e);
                    b.name.match(/(\.svg)$/) || (b.name += ".svg");
                    for (var w in b) b.hasOwnProperty(w) && (b[w] = u(b[w]), b[w] = A(b[w]));
                    b.name.match(/morph+(-)/) ? b.morph = !0 : b.morph = !1;
                    b.drawOnce = !1;
                    b.drawn = !1;
                    b.ending = !1;
                    a.data("saved_options", b);
                    "function" ==
                    typeof b.beforeUpdate && b.beforeUpdate();
                    k.ajax({
                        url: b.pathToFolder + b.name,
                        type: "GET",
                        dataType: "text",
                        global: !0,
                        success: function(c) {
                            a.addClass("livicon-evo-holder").removeClass("livicon-evo-error");
                            var d = c.match(/(id=[\"'](.*?)[\"'])/gi);
                            d && d.forEach(function(a) {
                                a = a.replace(/id=[\"']/i, "").replace(/[\"']/, "");
                                c = c.replace(new RegExp(a, "g"), a + "_" + H())
                            });
                            c = n.parse(c);
                            d = a.empty().append("<div>").children().addClass("lievo-svg-wrapper");
                            try { d[0].appendChild(c.node) } catch (l) { d.html(c.node) }
                            M(a, b);
                            "function" ==
                            typeof b.afterUpdate && b.afterUpdate()
                        },
                        error: function(b, c) {
                            a.addClass("livicon-evo-error");
                            0 === b.status && "error" === c ? a.html('<span><acronym title="Please use LivIconsEvo script on a working local or internet connected webserver, it does NOT work directly opened from a HDD.">Network Error</acronym></span>') : 404 === b.status && "error" === c ? a.html('<span><acronym title="Please check the &quot;name&quot; option and/or default &quot;pathToFolder&quot; one where all SVG LivIconEvo files are placed.">Not Found</acronym></span>') :
                                a.html('<span><acronym title="There is an unknown error. Please check for messages in Console (F12 key).">Unknown Error</acronym></span>')
                        }
                    })
                } else a.addLiviconEvo(e)
            })
        },
        changeLiviconEvo: function(b, a) {
            if (2 > arguments.length) var e = b === Object(b) ? b : {};
            else b === Object(b) ? e = b : (e = {}, e[b] = a);
            for (var c in e) e.hasOwnProperty(c) && (e[c] = u(e[c]), e[c] = A(e[c]));
            return this.each(function() {
                var a = k(this),
                    b = a.data(),
                    c = b.saved_options;
                if (c) {
                    var d = b.drawTL,
                        b = b.mainTL,
                        l = a.find("circle, ellipse, line, path, polygon, polyline, rect");
                    c.event_elem && c.event_elem.off(".LiviconEvo");
                    c.event_elem = C;
                    c = I(c);
                    c = k.extend(c, e);
                    d.pause().totalProgress(0).clear();
                    b.pause().totalProgress(0);
                    c.drawn = !0;
                    c.drawOnViewport = 0 == e.drawOnViewport ? !1 : !0;
                    a.eraseLiviconEvo(c);
                    var q = setTimeout(function() {
                        a.updateLiviconEvo(c);
                        clearTimeout(q)
                    }, 1E3 * (c.eraseDelay + c.eraseTime + c.eraseStagger * l.length))
                } else a.addLiviconEvo(e)
            })
        },
        drawLiviconEvo: function(b, a, e) {
            if (1 >= arguments.length)
                if (b === Object(b)) var c = b;
                else c = {}, c.force = b;
            else 2 === arguments.length ? b === Object(b) ?
                (c = b, c.force = a) : (c = {}, c[b] = a, c.force || (c.force = !1)) : (c = {}, c[b] = a, c.force = e);
            for (var f in c) c.hasOwnProperty(f) && (c[f] = u(c[f]), c[f] = A(c[f]));
            return this.each(function() {
                var a = k(this),
                    b = a.data(),
                    d = b.saved_options;
                if (d) {
                    var e = b.drawTL,
                        f = b.mainTL,
                        b = 0 === c.drawDelay || c.drawDelay ? c.drawDelay : d.drawDelay,
                        r = 0 === c.drawTime || c.drawTime ? c.drawTime : d.drawTime,
                        u = 0 === c.drawStagger || c.drawStagger ? c.drawStagger : d.drawStagger,
                        m = c.drawStartPoint ? c.drawStartPoint : d.drawStartPoint,
                        t = c.drawColor ? c.drawColor : d.drawColor,
                        p = 0 === c.drawColorTime || c.drawColorTime ? c.drawColorTime : d.drawColorTime,
                        B = c.drawEase ? c.drawEase : d.drawEase,
                        z = c.beforeDraw ? c.beforeDraw : d.beforeDraw,
                        x = c.afterDraw ? c.afterDraw : d.afterDraw,
                        E = c.duringDraw ? c.duringDraw : d.duringDraw,
                        D = "undefined" != typeof c.drawReversed ? c.drawReversed : d.drawReversed,
                        v = a.find("circle, ellipse, line, path, polygon, polyline, rect").not(".lievo-morphpattern").not(".lievo-donotdraw").not(".lievo-nohovercolor").get();
                    e.eventCallback("onStart", null);
                    e.eventCallback("onComplete",
                        null);
                    e.eventCallback("onUpdate", null);
                    0 >= b && (b = .001);
                    0 >= r && (r = .001);
                    A(c.force) && (e.clear(), e.pause().totalProgress(0), f.pause().totalProgress(0), d.drawn = !1);
                    if (!e.isActive() && !f.isActive() && !d.drawn) {
                        D && v.reverse();
                        if (d.morph && d.colorsWhenMorph) {
                            n(a.find("svg")[0]).selectAll("circle, ellipse, image, line, path, polygon, polyline, rect, text, use").forEach(function(a) {
                                a.data("curFill", k(a.node).attr("fill"));
                                a.data("curStroke", a.attr("stroke"));
                                a.data("curOpacity", a.attr("opacity"))
                            });
                            var y = n(a.find("svg")[0]).select(".lievo-checkshift"),
                                y = y.data("actionStroke")
                        }
                        var f = function() {
                                var a = n(this.target);
                                if (K || L) "square" === a.data("initStrokeLinecap").toLowerCase() && h.set(this.target, { attr: { "stroke-linecap": "round" } }), "miter" === a.data("initStrokeLinejoin").toLowerCase() && h.set(this.target, { attr: { "stroke-linejoin": "round" } });
                                "same" !== t ? (h.set(this.target, { strokeOpacity: 1, stroke: t }), "none" === a.data("curStroke") && a.attr({ "stroke-width": 1 / d.scaleStrokeFactor })) : (h.set(this.target, { strokeOpacity: 1 }), "none" === a.data("curStroke") && a.attr({
                                    "stroke-width": 1 /
                                        d.scaleStrokeFactor,
                                    stroke: a.data("curFill")
                                }), "solid" === d.style && a.hasClass("lievo-solidbg") && (d.morph && d.colorsWhenMorph && "end" === d.morphState ? y ? a.attr({ stroke: y }) : a.attr({ stroke: d.solidColorAction }) : a.attr({ stroke: d.solidColor })))
                            },
                            D = function() {
                                var a = n(this.target);
                                if (K || L) "square" === a.data("initStrokeLinecap").toLowerCase() && h.set(this.target, { attr: { "stroke-linecap": "square" } }), "miter" === a.data("initStrokeLinejoin").toLowerCase() && h.set(this.target, { attr: { "stroke-linejoin": "miter" } });
                                h.to(this.target,
                                    p, { stroke: a.data("curStroke"), fillOpacity: 1 })
                            },
                            C = function() { d.drawn = !0 };
                        e.clear();
                        "function" == typeof z && e.eventCallback("onStart", z);
                        "function" == typeof E && e.eventCallback("onUpdate", E);
                        e.eventCallback("onComplete", function() {
                            "function" == typeof x && x();
                            d.autoPlay && a.playLiviconEvo()
                        });
                        e.delay(b);
                        h.set(v, { strokeOpacity: 0, fillOpacity: 0 });
                        a.css("visibility", "visible");
                        "string" == typeof B && (B = J(B));
                        switch (m) {
                            case "middle":
                                h.set(v, { drawSVG: "0% 100%" });
                                e.staggerFrom(v, r, {
                                    drawSVG: "50% 50%",
                                    ease: B,
                                    onStart: f,
                                    onComplete: D
                                }, u, 0, C);
                                break;
                            case "end":
                                e.staggerFromTo(v, r, { drawSVG: "100% 100%" }, { drawSVG: "0% 100%", ease: B, onStart: f, onComplete: D }, u, 0, C);
                                break;
                            default:
                                e.staggerFromTo(v, r, { drawSVG: "0% 0%" }, { drawSVG: "0% 100%", ease: B, onStart: f, onComplete: D }, u, 0, C)
                        }
                        e.restart(!0)
                    }
                } else c.drawOnViewport = !0, a.addLiviconEvo(c)
            })
        },
        eraseLiviconEvo: function(b, a, e) {
            if (1 >= arguments.length)
                if (b === Object(b)) var c = b;
                else c = {}, c.force = b;
            else 2 === arguments.length ? b === Object(b) ? (c = b, c.force = a) : (c = {}, c[b] = a, c.force || (c.force = !1)) : (c = {}, c[b] = a, c.force = e);
            for (var f in c) c.hasOwnProperty(f) && (c[f] = u(c[f]), c[f] = A(c[f]));
            return this.each(function() {
                var a = k(this),
                    b = a.data(),
                    d = b.saved_options;
                if (d) {
                    var e = b.drawTL,
                        f = b.mainTL,
                        b = 0 === c.eraseDelay || c.eraseDelay ? c.eraseDelay : d.eraseDelay,
                        r = 0 === c.eraseTime || c.eraseTime ? c.eraseTime : d.eraseTime,
                        u = c.eraseStartPoint ? c.eraseStartPoint : d.eraseStartPoint,
                        m = c.eraseEase ? c.eraseEase : d.eraseEase,
                        t = c.beforeErase ? c.beforeErase : d.beforeErase,
                        p = c.afterErase ? c.afterErase : d.afterErase,
                        v = c.duringErase ? c.duringErase :
                        d.duringErase,
                        z = "undefined" != typeof c.eraseReversed ? c.eraseReversed : d.eraseReversed,
                        x = a.find("circle, ellipse, line, path, polygon, polyline, rect").not(".lievo-donotdraw").not(".lievo-nohovercolor").get();
                    0 >= b && (b = .001);
                    e.eventCallback("onStart", null);
                    e.eventCallback("onComplete", null);
                    e.eventCallback("onUpdate", null);
                    A(c.force) && (e.clear(), e.pause().totalProgress(0), f.pause().totalProgress(0), d.drawn = !0);
                    if (!e.isActive() && !f.isActive() && d.drawn) {
                        z && x.reverse();
                        d.morph && d.colorsWhenMorph && n(a.find("svg")[0]).selectAll("circle, ellipse, image, line, path, polygon, polyline, rect, text, use").forEach(function(a) {
                            a.data("curFill",
                                k(a.node).attr("fill"));
                            a.data("curStroke", a.attr("stroke"));
                            a.data("curOpacity", a.attr("opacity"))
                        });
                        var f = function() {
                                "none" === n(this.target).data("curStroke") && n(this.target).attr({ "stroke-width": 1 / d.scaleStrokeFactor, stroke: n(this.target).data("curFill") });
                                h.to(this.target, r, { fillOpacity: 0 })
                            },
                            z = function() { h.set(this.target, { strokeOpacity: 0, fillOpacity: 0 }); "none" === n(this.target).data("curStroke") && h.set(this.target, { "stroke-width": 0, stroke: "none" }) },
                            y = function() { d.drawn = !1 };
                        e.clear();
                        "function" ==
                        typeof t && e.eventCallback("onStart", t);
                        "function" == typeof p && e.eventCallback("onComplete", p);
                        "function" == typeof v && e.eventCallback("onUpdate", v);
                        "string" == typeof m && (m = J(m));
                        e.delay(b);
                        h.set(x, { strokeOpacity: 1, fillOpacity: 1 });
                        a.css("visibility", "visible");
                        switch (u) {
                            case "middle":
                                e.staggerFromTo(x, r, { drawSVG: "0% 100%" }, { drawSVG: "50% 50%", ease: m, onStart: f, onComplete: z }, d.eraseStagger, 0, y);
                                break;
                            case "end":
                                e.staggerFromTo(x, r, { drawSVG: "0% 100%" }, { drawSVG: "100% 100%", ease: m, onStart: f, onComplete: z }, d.eraseStagger,
                                    0, y);
                                break;
                            default:
                                e.staggerFromTo(x, r, { drawSVG: "0% 100%" }, { drawSVG: 0, ease: m, onStart: f, onComplete: z }, d.eraseStagger, 0, y)
                        }
                        e.restart(!0)
                    }
                } else a.addLiviconEvo(c)
            })
        },
        playLiviconEvo: function(b, a, e) {
            if (1 >= arguments.length)
                if (b === Object(b)) var c = b;
                else c = {}, c.force = b;
            else 2 === arguments.length ? b === Object(b) ? (c = b, c.force = a) : (c = {}, c[b] = a, c.force || (c.force = !1)) : (c = {}, c[b] = a, c.force = e);
            for (var f in c) c.hasOwnProperty(f) && (c[f] = u(c[f]), c[f] = A(c[f]));
            return this.each(function() {
                var a = k(this),
                    b = a.data(),
                    d = b.saved_options;
                if (d) {
                    var a = b.drawTL,
                        b = b.mainTL,
                        e = 0 === c.duration || c.duration ? c.duration : d.duration,
                        f = 0 === c.delay || c.delay ? c.delay : d.delay,
                        h = 0 === c.repeat || c.repeat ? c.repeat : d.repeat,
                        n = 0 === c.repeatDelay || c.repeatDelay ? c.repeatDelay : d.repeatDelay,
                        m = c.beforeAnim ? c.beforeAnim : d.beforeAnim,
                        t = c.afterAnim ? c.afterAnim : d.afterAnim,
                        p = c.duringAnim ? c.duringAnim : d.duringAnim;
                    d.animated && (A(c.force) && (a.pause().totalProgress(1), b.pause().totalProgress(0), d.drawn = !0), "default" === e && (e = d.def_duration), b.getChildren(!1, !1, !0).forEach(function(a) { a.duration(e) }),
                        0 >= f && (f = .001), b.delay(f), "default" === h ? h = d.def_repeat : "loop" === h && (h = -1), "default" === n && (n = d.def_repeatDelay), 0 >= n && (n = .001), d.morph ? (b.repeat(0).repeatDelay(0), "function" == typeof m && b.eventCallback("onStart", m), "function" == typeof p && b.eventCallback("onUpdate", p), b.eventCallback("onComplete", function() { d.curMorphState = "end" === d.morphState ? "start" : "end"; "function" == typeof t && t() }), b.eventCallback("onReverseComplete", function() {
                            d.curMorphState = "end" === d.morphState ? "end" : "start";
                            "function" == typeof t &&
                                t()
                        }), a.isActive() || b.isActive() || !d.drawn || (a = b.progress(), 0 === a ? b.restart(!0) : b.paused() && 0 < a && 1 > a ? b.resume() : b.pause().reverse(0))) : (b.repeat(h).repeatDelay(n), "function" == typeof m && b.eventCallback("onStart", m), "function" == typeof t && -1 !== h && b.eventCallback("onComplete", t), "function" == typeof p && b.eventCallback("onUpdate", p), a.isActive() || b.isActive() || !d.drawn || (a = b.totalProgress(), b.paused() && 0 < a && 1 > a ? b.resume() : (b.restart(!0), d.ending = !0))))
                } else a.addLiviconEvo(c)
            })
        },
        stopLiviconEvo: function() {
            return this.each(function() {
                var b =
                    k(this),
                    a = b.data(),
                    e = a.saved_options;
                e ? (b = a.mainTL, e.morph ? b.pause().progress(0) : (b.pause().totalProgress(0), e.ending = !1)) : b.addLiviconEvo()
            })
        },
        pauseLiviconEvo: function() {
            return this.each(function() {
                var b = k(this).data("mainTL");
                b && b.pause()
            })
        },
        resumeLiviconEvo: function() {
            return this.each(function() {
                var b = k(this).data("mainTL");
                b && b.resume()
            })
        },
        removeLiviconEvo: function(b, a, e) {
            if (1 >= arguments.length)
                if (b === Object(b)) var c = b;
                else c = {}, c.total = b;
            else 2 === arguments.length ? b === Object(b) ? (c = b, c.total = a) :
                (c = {}, c[b] = a, c.total || (c.total = !1)) : (c = {}, c[b] = a, c.total = e);
            return this.each(function() {
                var a = k(this),
                    b = a.data("saved_options");
                if (b) {
                    var e = c.beforeRemove ? c.beforeRemove : b.beforeRemove,
                        d = c.afterRemove ? c.afterRemove : b.afterRemove;
                    b.event_elem && b.event_elem.off(".LiviconEvo");
                    b.event_elem = C;
                    "function" == typeof e && e();
                    a.removeData("saved_options drawTL mainTL");
                    A(c.total) ? a.remove() : a.empty();
                    "function" == typeof d && d()
                }
            })
        },
        liviconEvoState: function(b) {
            if (0 === arguments.length) return k(this).data("saved_options").curMorphState;
            if (1 <= arguments.length) return this.each(function() {
                var a = k(this).data("saved_options"),
                    e = k(this).data("mainTL");
                "start" === b.toLowerCase() ? e && a.morph && ("end" === a.morphState ? e.pause().progress(1) : e.pause().progress(0), a.curMorphState = "start") : "end" === b.toLowerCase() && e && a.morph && ("end" === a.morphState ? e.pause().progress(0) : e.pause().progress(1), a.curMorphState = "end")
            })
        },
        liviconEvoOptions: function() {
            var b = k(this).data("saved_options");
            if (b) {
                var a = {};
                a.afterAdd = b.afterAdd;
                a.afterAnim = b.afterAnim;
                a.afterDraw =
                    b.afterDraw;
                a.afterErase = b.afterErase;
                a.afterRemove = b.afterRemove;
                a.afterUpdate = b.afterUpdate;
                a.allowMorphImageTransform = b.allowMorphImageTransform;
                a.animated = b.animated;
                a.autoPlay = b.autoPlay;
                a.beforeAdd = b.beforeAdd;
                a.beforeAnim = b.beforeAnim;
                a.beforeDraw = b.beforeDraw;
                a.beforeErase = b.beforeErase;
                a.beforeRemove = b.beforeRemove;
                a.beforeUpdate = b.beforeUpdate;
                a.brightness = b.brightness;
                a.colorsHoverTime = b.colorsHoverTime;
                a.colorsOnHover = !1 === b.colorsOnHover ? "none" : b.colorsOnHover;
                a.colorsWhenMorph = !1 ===
                    b.colorsWhenMorph ? "none" : b.colorsWhenMorph;
                a.delay = .001 === b.delay ? 0 : b.delay;
                a.drawColor = b.drawColor;
                a.drawColorTime = b.drawColorTime;
                a.drawDelay = .001 === b.drawDelay ? 0 : b.drawDelay;
                a.drawEase = b.drawEase;
                a.drawOnViewport = b.drawOnViewport;
                a.drawReversed = b.drawReversed;
                a.drawStagger = b.drawStagger;
                a.drawStartPoint = b.drawStartPoint;
                a.drawTime = b.drawTime;
                a.duration = b.duration;
                a.duringAnim = b.duringAnim;
                a.duringDraw = b.duringDraw;
                a.duringErase = b.duringErase;
                a.eraseDelay = .001 === b.eraseDelay ? 0 : b.eraseDelay;
                a.eraseEase =
                    b.eraseEase;
                a.eraseReversed = b.eraseReversed;
                a.eraseStagger = b.eraseStagger;
                a.eraseStartPoint = b.eraseStartPoint;
                a.eraseTime = b.eraseTime;
                a.eventOn = b.eventOn;
                a.eventType = !1 === b.eventType ? "none" : b.eventType;
                a.fillColor = b.fillColor;
                a.fillColorAction = b.fillColorAction;
                a.flipHorizontal = b.flipHorizontal;
                a.flipVertical = b.flipVertical;
                a.keepStrokeWidthOnResize = b.keepStrokeWidthOnResize;
                a.morphImage = !1 === b.morphImage ? "none" : b.morphImage;
                a.morphState = b.morphState;
                a.name = b.name;
                a.pathToFolder = b.pathToFolder;
                a.repeat =
                    b.repeat;
                a.repeatDelay = b.repeatDelay;
                a.rotate = !1 === b.rotate ? "none" : b.rotate;
                a.saturation = b.saturation;
                a.size = b.size;
                a.solidColor = b.solidColor;
                a.solidColorAction = b.solidColorAction;
                a.solidColorBg = b.solidColorBg;
                a.solidColorBgAction = b.solidColorBgAction;
                a.strokeColor = b.strokeColor;
                a.strokeColorAction = b.strokeColorAction;
                a.strokeColorAlt = b.strokeColorAlt;
                a.strokeColorAltAction = b.strokeColorAltAction;
                a.strokeStyle = b.strokeStyle;
                a.strokeWidth = b.strokeWidth;
                a.strokeWidthFactorOnHover = !1 === b.strokeWidthFactorOnHover ?
                    "none" : b.strokeWidthFactorOnHover;
                a.strokeWidthOnHoverTime = b.strokeWidthOnHoverTime;
                a.style = b.style;
                a.touchEvents = b.touchEvents;
                a.tryToSharpen = b.tryToSharpen;
                a.viewportShift = !1 === b.viewportShift ? "none" : b.viewportShift;
                a.def_duration = b.def_duration;
                a.def_repeat = b.def_repeat;
                a.def_repeatDelay = b.def_repeatDelay;
                return a
            }
            return C
        }
    });
    k(document).ready(function() { k(".livicon-evo").addLiviconEvo() });
    k(window).on("orientationchange", function() { k(window).resize() });
    H.counter = 1
})(jQuery);